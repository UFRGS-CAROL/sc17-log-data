2017-03-01 22:36:56:Starting flip_value script
2017-03-01 22:36:56:Initialization strings:
2017-03-01 22:36:57:(1) target extended-remote | ssh -T mic0 gdbserver --multi -
2017-03-01 22:36:57:(2) set sysroot /opt/mpss/3.7/sysroots/k1om-mpss-linux/
2017-03-01 22:36:57:(3) set sysroot /opt/mpss/3.7/sysroots/k1om-mpss-linux/
2017-03-01 22:36:57:(4) file /micNfs/gdb-fault-injection/injector/bin/lavamd/lavamd_check
2017-03-01 22:36:57:(5) set remote exec-file /micNfs/gdb-fault-injection/injector/bin/lavamd/lavamd_check
2017-03-01 22:36:57:(6) set args 228 15 /micNfs/gdb-fault-injection/injector/bin/lavamd/input_distance_228_15 /micNfs/gdb-fault-injection/injector/bin/lavamd/input_charges_228_15 /micNfs/gdb-fault-injection/injector/bin/lavamd/output_gold_228_15 1
2017-03-01 22:36:57:initSignal:3
2017-03-01 22:36:57:endSignal:6
2017-03-01 22:36:57:seqSignal:30
2017-03-01 22:37:01:Backtrace BEGIN:
2017-03-01 22:37:01:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:01:50	    char * input_charges;
51	    char * output_gold;
52	
53	    int i, j, k, l, m, n;
54	
55	    par_str par_cpu;
56	    dim_str dim_cpu;
57	    box_str* box_cpu;
58	    FOUR_VECTOR* rv_cpu;
59	    fp* qv_cpu;

2017-03-01 22:37:01:Backtrace END
2017-03-01 22:37:02:Backtrace BEGIN:
2017-03-01 22:37:02:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:02:60	    FOUR_VECTOR* fv_cpu;
61	    FOUR_VECTOR* fv_cpu_GOLD;
62	    int nh;
63	
64	    dim_cpu.cores_arg = 1;
65	    dim_cpu.boxes1d_arg = 1;
66	
67	    if(argc == 7) {
68	        dim_cpu.cores_arg  = atoi(argv[1]);
69	        dim_cpu.boxes1d_arg = atoi(argv[2]);

2017-03-01 22:37:02:Backtrace END
2017-03-01 22:37:03:Backtrace BEGIN:
2017-03-01 22:37:03:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:03:70	        input_distance = argv[3];
71	        input_charges = argv[4];
72	        output_gold = argv[5];
73	        iteractions = atoi(argv[6]);
74	    } else {
75	        usage();
76	        exit(1);
77	    }
78	
79	

2017-03-01 22:37:03:Backtrace END
2017-03-01 22:37:04:Backtrace BEGIN:
2017-03-01 22:37:04:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:04:80	    printf("Configuration used: cores = %d, boxes1d = %d\n", dim_cpu.cores_arg, dim_cpu.boxes1d_arg);
81	
82	    par_cpu.alpha = 0.5;
83	
84	    dim_cpu.number_boxes = dim_cpu.boxes1d_arg * dim_cpu.boxes1d_arg * dim_cpu.boxes1d_arg;
85	
86	    dim_cpu.space_elem = dim_cpu.number_boxes * NUMBER_PAR_PER_BOX;
87	    dim_cpu.space_mem = dim_cpu.space_elem * sizeof(FOUR_VECTOR);
88	    dim_cpu.space_mem2 = dim_cpu.space_elem * sizeof(fp);
89	

2017-03-01 22:37:04:Backtrace END
2017-03-01 22:37:05:Backtrace BEGIN:
2017-03-01 22:37:05:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:05:90	    dim_cpu.box_mem = dim_cpu.number_boxes * sizeof(box_str);
91	
92	    box_cpu = (box_str*)malloc(dim_cpu.box_mem);
93	
94	    nh = 0;
95	
96	    for(i=0; i<dim_cpu.boxes1d_arg; i++) {
97	
98	        for(j=0; j<dim_cpu.boxes1d_arg; j++) {
99	

2017-03-01 22:37:05:Backtrace END
2017-03-01 22:37:06:Backtrace BEGIN:
2017-03-01 22:37:06:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:06:100	            for(k=0; k<dim_cpu.boxes1d_arg; k++) {
101	
102	                box_cpu[nh].x = k;
103	                box_cpu[nh].y = j;
104	                box_cpu[nh].z = i;
105	                box_cpu[nh].number = nh;
106	                box_cpu[nh].offset = nh * NUMBER_PAR_PER_BOX;
107	
108	                box_cpu[nh].nn = 0;
109	

2017-03-01 22:37:06:Backtrace END
2017-03-01 22:37:07:Backtrace BEGIN:
2017-03-01 22:37:07:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:07:110	                for(l=-1; l<2; l++) {
111	
112	                    for(m=-1; m<2; m++) {
113	
114	                        for(n=-1; n<2; n++) {
115	
116	                            if((((i+l)>=0 && (j+m)>=0 && (k+n)>=0)==true && ((i+l)<dim_cpu.boxes1d_arg && (j+m)<dim_cpu.boxes1d_arg && (k+n)<dim_cpu.boxes1d_arg)==true) && (l==0 && m==0 && n==0)==false) {
117	
118	                                box_cpu[nh].nei[box_cpu[nh].nn].x = (k+n);
119	                                box_cpu[nh].nei[box_cpu[nh].nn].y = (j+m);

2017-03-01 22:37:07:Backtrace END
2017-03-01 22:37:09:Backtrace BEGIN:
2017-03-01 22:37:09:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:09:120	                                box_cpu[nh].nei[box_cpu[nh].nn].z = (i+l);
121	                                box_cpu[nh].nei[box_cpu[nh].nn].number = (box_cpu[nh].nei[box_cpu[nh].nn].z * dim_cpu.boxes1d_arg * dim_cpu.boxes1d_arg) + (box_cpu[nh].nei[box_cpu[nh].nn].y * dim_cpu.boxes1d_arg) + box_cpu[nh].nei[box_cpu[nh].nn].x;
122	                                box_cpu[nh].nei[box_cpu[nh].nn].offset = box_cpu[nh].nei[box_cpu[nh].nn].number * NUMBER_PAR_PER_BOX;
123	
124	                                box_cpu[nh].nn = box_cpu[nh].nn + 1;
125	
126	                            }
127	                        }
128	                    }
129	                }

2017-03-01 22:37:09:Backtrace END
2017-03-01 22:37:10:Backtrace BEGIN:
2017-03-01 22:37:10:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:10:130	
131	                nh = nh + 1;
132	            }
133	        }
134	    }
135	
136	
137	    srand(time(NULL));
138	
139	    FILE *file;

2017-03-01 22:37:10:Backtrace END
2017-03-01 22:37:11:Backtrace BEGIN:
2017-03-01 22:37:11:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:11:140	
141	    if( (file = fopen(input_distance, "rb" )) == 0 ) {
142	        printf( "The file 'input_distances' was not opened\n" );
143	        exit(1);
144	    }
145	
146	    rv_cpu = (FOUR_VECTOR*)malloc(dim_cpu.space_mem);
147	    for(i=0; i<dim_cpu.space_elem; i=i+1) {
148	        fread(&(rv_cpu[i].v), 1, sizeof(double), file);
149	        fread(&(rv_cpu[i].x), 1, sizeof(double), file);

2017-03-01 22:37:11:Backtrace END
2017-03-01 22:37:12:Backtrace BEGIN:
2017-03-01 22:37:12:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:12:150	        fread(&(rv_cpu[i].y), 1, sizeof(double), file);
151	        fread(&(rv_cpu[i].z), 1, sizeof(double), file);
152	    }
153	
154	    fclose(file);
155	
156	    if( (file = fopen(input_charges, "rb" )) == 0 ) {
157	        printf( "The file 'input_charges' was not opened\n" );
158	        exit(1);
159	    }

2017-03-01 22:37:12:Backtrace END
2017-03-01 22:37:13:Backtrace BEGIN:
2017-03-01 22:37:13:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:13:160	
161	    qv_cpu = (fp*)malloc(dim_cpu.space_mem2);
162	    for(i=0; i<dim_cpu.space_elem; i=i+1) {
163	        fread(&(qv_cpu[i]), 1, sizeof(double), file);
164	    }
165	    fclose(file);
166	
167	    fv_cpu = (FOUR_VECTOR*)malloc(dim_cpu.space_mem);
168	    fv_cpu_GOLD = (FOUR_VECTOR*)malloc(dim_cpu.space_mem);
169	    if( (file = fopen(output_gold, "rb" )) == 0 ) {

2017-03-01 22:37:13:Backtrace END
2017-03-01 22:37:14:Backtrace BEGIN:
2017-03-01 22:37:14:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:14:170	        printf( "The file 'output_forces' was not opened\n" );
171	        exit(1);
172	    }
173	    for(i=0; i<dim_cpu.space_elem; i=i+1) {
174	        fv_cpu[i].v = 0;
175	        fv_cpu[i].x = 0;
176	        fv_cpu[i].y = 0;
177	        fv_cpu[i].z = 0;
178	
179	        fread(&(fv_cpu_GOLD[i].v), 1, sizeof(double), file);

2017-03-01 22:37:14:Backtrace END
2017-03-01 22:37:15:Backtrace BEGIN:
2017-03-01 22:37:15:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:15:180	        fread(&(fv_cpu_GOLD[i].x), 1, sizeof(double), file);
181	        fread(&(fv_cpu_GOLD[i].y), 1, sizeof(double), file);
182	        fread(&(fv_cpu_GOLD[i].z), 1, sizeof(double), file);
183	    }
184	
185	    fclose(file);
186	
187	#ifdef LOGS
188	    char test_info[100];
189	    snprintf(test_info, 100, "box:%d spaceElem:%ld cores:%d", dim_cpu.boxes1d_arg,dim_cpu.space_elem,dim_cpu.cores_arg);

2017-03-01 22:37:15:Backtrace END
2017-03-01 22:37:17:Backtrace BEGIN:
2017-03-01 22:37:17:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:17:190	    start_log_file((char *)"openmpLavaMD", test_info);
191	    set_max_errors_iter(MAX_ERR_ITER_LOG);
192	    set_iter_interval_print(5);
193	#endif /* LOGS */
194	
195	#ifdef TIMING
196		setup_end = timing_get_time();
197	#endif
198	    int loop;
199	    for(loop=0; loop<iteractions; loop++) {

2017-03-01 22:37:17:Backtrace END
2017-03-01 22:37:18:Backtrace BEGIN:
2017-03-01 22:37:18:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:18:200	#ifdef TIMING
201		loop_start = timing_get_time();
202	#endif
203	
204		for(i=0; i<dim_cpu.space_elem; i=i+1) {
205	            fv_cpu[i].v = 0;
206	            fv_cpu[i].x = 0;
207	            fv_cpu[i].y = 0;
208	            fv_cpu[i].z = 0;
209		}

2017-03-01 22:37:18:Backtrace END
2017-03-01 22:37:19:Backtrace BEGIN:
2017-03-01 22:37:19:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:19:210	
211	#ifdef ERR_INJ
212		if(loop == 2){
213			printf("injecting error, changing input!\n");
214			rv_cpu[0].v = rv_cpu[0].v*2;
215			rv_cpu[0].x = rv_cpu[0].x*-1;
216			rv_cpu[0].y = rv_cpu[0].y*6;
217			rv_cpu[0].z = rv_cpu[0].z*-3;
218			qv_cpu[0] = qv_cpu[0]*-2;
219		}else if(loop == 3){

2017-03-01 22:37:19:Backtrace END
2017-03-01 22:37:20:Backtrace BEGIN:
2017-03-01 22:37:20:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:20:220			printf("injecting error, restoring input!\n");
221			rv_cpu[0].v = rv_cpu[0].v/2;
222			rv_cpu[0].x = rv_cpu[0].x/-1;
223			rv_cpu[0].y = rv_cpu[0].y/6;
224			rv_cpu[0].z = rv_cpu[0].z/-3;
225			qv_cpu[0] = qv_cpu[0]/-2;
226		} else if (loop == 4){
227			printf("get ready, infinite loop...\n");
228			fflush(stdout);
229			while(1){sleep(100);}

2017-03-01 22:37:20:Backtrace END
2017-03-01 22:37:21:Backtrace BEGIN:
2017-03-01 22:37:21:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:21:230		}
231	#endif
232	#ifdef TIMING
233		kernel_start = timing_get_time();
234	#endif
235	#ifdef LOGS
236	    start_iteration();
237	#endif /* LOGS */
238	    kernel_cpu(	par_cpu,
239	                dim_cpu,

2017-03-01 22:37:21:Backtrace END
2017-03-01 22:37:22:Backtrace BEGIN:
2017-03-01 22:37:22:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:22:240	                box_cpu,
241	                rv_cpu,
242	                qv_cpu,
243	                fv_cpu);
244	
245	#ifdef LOGS
246	        end_iteration();
247	#endif /* LOGS */
248	#ifdef TIMING
249		kernel_end = timing_get_time();

2017-03-01 22:37:22:Backtrace END
2017-03-01 22:37:24:Backtrace BEGIN:
2017-03-01 22:37:24:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:24:250	#endif
251	
252	#ifdef TIMING
253		check_start = timing_get_time();
254	#endif
255	        int part_error=0;
256	        #pragma omp parallel for  reduction(+:part_error)
257	        for(i=0; i<dim_cpu.space_elem; i++) {
258			int thread_error=0;
259		    if ((fabs((fv_cpu[i].v - fv_cpu_GOLD[i].v) / fv_cpu[i].v) > 0.0000000001) || (fabs((fv_cpu[i].v - fv_cpu_GOLD[i].v) / fv_cpu_GOLD[i].v) > 0.0000000001)){

2017-03-01 22:37:24:Backtrace END
2017-03-01 22:37:25:Backtrace BEGIN:
2017-03-01 22:37:25:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:25:260	            //if(fv_cpu_GOLD[i].v != fv_cpu[i].v) {
261	                thread_error++;
262	            }
263		    if ((fabs((fv_cpu[i].x - fv_cpu_GOLD[i].x) / fv_cpu[i].x) > 0.0000000001) || (fabs((fv_cpu[i].x - fv_cpu_GOLD[i].x) / fv_cpu_GOLD[i].x) > 0.0000000001)){
264	            //if(fv_cpu_GOLD[i].x != fv_cpu[i].x) {
265	                thread_error++;
266	            }
267		    if ((fabs((fv_cpu[i].y - fv_cpu_GOLD[i].y) / fv_cpu[i].y) > 0.0000000001) || (fabs((fv_cpu[i].y - fv_cpu_GOLD[i].y) / fv_cpu_GOLD[i].y) > 0.0000000001)){
268	            //if(fv_cpu_GOLD[i].y != fv_cpu[i].y) {
269	                thread_error++;

2017-03-01 22:37:25:Backtrace END
2017-03-01 22:37:26:Backtrace BEGIN:
2017-03-01 22:37:26:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:26:270	            }
271		    if ((fabs((fv_cpu[i].z - fv_cpu_GOLD[i].z) / fv_cpu[i].z) > 0.0000000001) || (fabs((fv_cpu[i].z - fv_cpu_GOLD[i].z) / fv_cpu_GOLD[i].z) > 0.0000000001)){
272	            //if(fv_cpu_GOLD[i].z != fv_cpu[i].z) {
273	                thread_error++;
274	            }
275	            if (thread_error  > 0) {
276	               // #pragma omp critical
277	                {
278	                    part_error++;
279			    char error_detail[300];

2017-03-01 22:37:26:Backtrace END
2017-03-01 22:37:27:Backtrace BEGIN:
2017-03-01 22:37:27:#0  0x00007ffff7931ff1 in ?? ()
#1  0x00007ffff788c60a in ?? ()
#2  0x0000000000000000 in ?? ()

2017-03-01 22:37:27:280	
281	                    snprintf(error_detail, 300, "p: [%d], ea: %d, v_r: %1.16e, v_e: %1.16e, x_r: %1.16e, x_e: %1.16e, y_r: %1.16e, y_e: %1.16e, z_r: %1.16e, z_e: %1.16e\n", i, thread_error, fv_cpu[i].v, fv_cpu_GOLD[i].v, fv_cpu[i].x, fv_cpu_GOLD[i].x, fv_cpu[i].y, fv_cpu_GOLD[i].y, fv_cpu[i].z, fv_cpu_GOLD[i].z);
282				printf("error: %s\n",error_detail);
283	                    thread_error = 0;
284	                }
285	            }
286	
287	
288	        }
289	        #pragma omp parallel for  reduction(+:part_error)

2017-03-01 22:37:27:Backtrace END
2017-03-01 22:37:42:event type: exit
2017-03-01 22:37:42:exit code: 0
